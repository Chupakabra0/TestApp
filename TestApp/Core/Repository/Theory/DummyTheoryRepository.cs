using System;
using System.Windows.Documents;

namespace TestApp.Core.Repository.Theory {
    public class DummyTheoryRepository : ITheoryRepository {
        private static readonly string SavageStr  = "<?xml version=\"1.0\"?> <FlowDocument PageHeight=\"2600\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:controls=\"clr-namespace:WpfMath.Controls;assembly=WpfMath\"> <Paragraph> Критерій оптимальності Севіджа відповідає поведінці особи, яку мучать докори сумління щодо невдалого вибору стратегії. </Paragraph> <Paragraph> Якщо природа буде в стані <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"\\beta_j\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, то найкращим розв’язком буде той, якому відповідають найменші втрати в разі цього стану природи. </Paragraph> <Paragraph> Якщо ж був обраний інший розв’язок, що призвів до втрат <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"l_{i j}\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, то особа буде відчувати жаль, що може бути визначений як: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"s_{i j} = l_{i j} - \\min_{i} l_{i j} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Згідно з критерієм Севіджа із двох розв’язків кращим є той, для якого найбільший можливий жаль є мінімальний, тобто: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"M_{s}(\\alpha_{i}) = \\max_{j} s_{i j} \\rightarrow \\min_{i} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> <Bold>Алгоритм пошуку нерандомізованого розв’язку за критерієм Севіджа</Bold> </Paragraph> <List MarkerStyle=\"Decimal\"> <ListItem> <Paragraph> Перейти від матриці втрат L до матриці жалю S. Для цього необхідно знайти в кожному стовпці найменший елемент та відняти його від кожного елемента даного стовпця: </Paragraph> <BlockUIContainer Margin=\"0, 10\"> <controls:FormulaControl Formula=\"s_{i j} = l_{i j} - \\min_{i} l_{i j} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> </ListItem> <ListItem> <Paragraph> Для кожного рядку в матриці жалю знайти найбільший елемент: </Paragraph> <BlockUIContainer Margin=\"0, 10\"> <controls:FormulaControl Formula=\"M_{s} (\\alpha_{i}) = \\max_{j} s_{i j} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> </ListItem> <ListItem> <Paragraph> Обрати як розв’язок таке <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"\\alpha_i\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, якому відповідає найменше <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"M_{s}(\\alpha_{i})\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>. </Paragraph> </ListItem> </List> <Paragraph> <Bold><Italic>Приклад:</Italic></Bold> </Paragraph> <Paragraph> Нехай матриця втрат має вигляд: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"L = \\pmatrix{0 &amp; 4 \\cr 5 &amp; 1 \\cr 6 &amp; 3 \\cr 3 &amp; 2 } \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Перейдемо до матриці жалю. Найменший елемент у першому стовпці – 0, а в другому – 1. Отже, віднімемо від усіх елементів першого стовпця 0, а від усіх елементів другого – 1. Одержимо таку матрицю жалю: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"S = \\pmatrix{0 &amp; 3 \\cr 5  &amp; 0 \\cr 6  &amp; 2 \\cr 3  &amp; 1 } \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> У цій матриці знайдемо максимальний елемент у кожному рядку: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"M_{s}(\\alpha_{1})=3, M_{s}(\\alpha_{2})=5, M_{s}(\\alpha_{3})=6, M_{s}(\\alpha_{4})=3 \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Оптимальний розв’язок – 3. У цьому випадку матимемо дві стратегії, що відповідають оптимальному нерандомізованому розв’язку – першу та четверту. </Paragraph> <Paragraph> <Bold>Оцінка оптимальності розв’язку</Bold> </Paragraph> <Paragraph> Згідно з критерієм Севіджа оцінка оптимальності розв’язку здійснюється за допомогою оцінки ймовірного жалю особи, яка зробила неправильний вибір. Оцінка жалю знаходиться за формулою: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"s_{i j} = l_{i j} - \\min_{i}l_{i j} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Очевидно, що перехід від матриці втрат до матриці жалю геометрично відповідає паралельному перенесенню осей координат до їх дотику із платіжною множиною D. Точки самої платіжної множини D змінять свої координати. Застосуємо мінімаксний критерій до платіжної множини із новими координатами, тобто знайдемо першу точку перетину нової платіжної множини із прямокутним клином. </Paragraph> <Paragraph> <Bold>Алгоритм пошуку рандомізованого розв’язку за критерієм Севіджа</Bold> </Paragraph> <List MarkerStyle=\"Decimal\"> <ListItem> <Paragraph> Побудувати платіжну множину D за матрицею втрат </Paragraph> </ListItem> <ListItem> <Paragraph> Перенести осі координат до їх першого дотику до платіжної множини D. Одержимо систему координат: </Paragraph> <BlockUIContainer Margin=\"0, 10\"> <controls:FormulaControl Formula=\"L_{1}' O' L_{2}' \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> </ListItem> <ListItem> <Paragraph> Перерахувати координати точок платіжної множини D відповідно до нової системи координат. </Paragraph> </ListItem> <ListItem> <Paragraph> Побудувати прямокутний клин у новій системі координат та рухати його по прямій до першого перетину із платіжною множиною. Визначити точки, що задають відрізок платіжної множини, із яким перетнувся клин. </Paragraph> </ListItem> <ListItem> <Paragraph> Записати опуклу комбінацію кінців відрізка, а саме: </Paragraph> <BlockUIContainer Margin=\"0, 10\"> <controls:FormulaControl Formula=\"x \\pmatrix{l_{i 1}' \\cr l_{i 2}' } + (1 - x) \\pmatrix{l_{j 1}' \\cr l_{j 2}'} = \\pmatrix{L_{1}' \\cr L_{2}'} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> </ListItem> <ListItem> <Paragraph> Побудувати рівняння й розв’язавши його, знайти x: </Paragraph> <BlockUIContainer Margin=\"0, 10\"> <controls:FormulaControl Formula=\"xl_{i 1}' + (1 - x)l_{j 1}' = xl_{i 2}' + (1 - x)l_{j 2}' \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> </ListItem> <ListItem> <Paragraph> Рандомізований розв’язок буде такий: </Paragraph> <BlockUIContainer Margin=\"0, 10\"> <controls:FormulaControl Formula=\"( 0;...; 0; x;0 ; 1-x; 0;...; 0) \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> </ListItem> </List> <Paragraph> <Bold><Italic>Приклад:</Italic></Bold> </Paragraph> <Paragraph> Нехай матриця втрат має вигляд: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"L = \\pmatrix{0 &amp; 4 \\cr 5 &amp; 1 \\cr 6 &amp; 3 \\cr 3 &amp; 2 } \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Геометрична інтерпретація наведена (у дужках подані нові ординати точок, абсциси точок не змінені). Зауважимо: оскільки точка <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"\\alpha_1\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer> лежить на осі координат <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"L_2\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, то вісь <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"L_2\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer> збігатиметься із віссю <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"L_{2}'\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, а прямокутний клин перетинається із відрізком, що з’єднує точки <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"\\alpha_{1}(0;3)\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer> та <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"\\alpha_{4}'(3;1)\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>. </Paragraph> <Paragraph> Знайдемо координати точки перетину: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"x \\pmatrix{0 \\cr 3} + (1 - x) \\pmatrix{3 \\cr 1} = \\pmatrix{L_{1} \\cr L_{2}} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Розв'язком цієї системи буде: </Paragraph> <BlockUIContainer><controls:FormulaControl Formula=\"x = \\frac{2}{5} \" Scale=\"20\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\" SnapsToDevicePixels=\"True\"/></BlockUIContainer> <Paragraph> Тобто рандомізований розв’язок за цим критерієм буде </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"(\\frac{2}{5}; 0; 0; \\frac{3}{5}) \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Отже, у двох випадках ми діємо за першим варіантом і в трьох – за четвертим. </Paragraph> </FlowDocument>";
        private static readonly string PearsonStr = "<?xml version=\"1.0\"?> <FlowDocument PageHeight=\"2000\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:controls=\"clr-namespace:WpfMath.Controls;assembly=WpfMath\"> <Paragraph> Критерій оптимальності Неймана-Пірсона застосовується тоді, коли природа може знаходиться у двох станах, один із яких можна контролювати, а інший – ні. Для стану, який ми можемо контролювати, вводиться граничне значення <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"l^{*}\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, і всі допустимі розв’язки, які для цього стану призводять до втрат, більших за граничне значення, виключаються з розгляду. </Paragraph> <Paragraph> У геометричній інтерпретації із платіжної множини виключаються всі розв’язки для яких значення за станом, що контролюється, більші за граничне значення. З усіх інших точок множини вибирають ту, для якої значення за станом,що не контролюється, найменше. </Paragraph> <Paragraph> Найчастiше крiтерiй Неймана-Пірсона використовується в радiолокацiї, коли виникає необхiднiсть розпiзнати цiль i дати команду або на те щоб її знищити, або на те щоб пропустити. Тут можливi помилки 1 та 2 роду. Чужа цiль розпiзнена як своя i пропущена. Своя цiль розпiзнана як чужа i дана команда на знищення. </Paragraph> <Paragraph> <Bold>Алгоритм пошуку нерандомізованого розв’язку за критерієм Неймана-Пірсона</Bold> </Paragraph> <List MarkerStyle=\"Decimal\"> <ListItem> <Paragraph> Виключити із розгляду всі стратегії, яким відповідають втрати, більші за допустиме граничне значення. </Paragraph> </ListItem> <ListItem> <Paragraph> Обрати як розв’язок таке <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"\\alpha_{i} \" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, якому відповідають найменші втрати для стану, що не контролюється (у відповідному стовпці цій стратегії відповідає менше значення). </Paragraph> </ListItem> </List> <Paragraph> <Bold><Italic>Приклад:</Italic></Bold> </Paragraph> <Paragraph> Нехай матриця втрат має вигляд: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"L = \\pmatrix{0 &amp; 4 \\cr 5 &amp; 1 \\cr 6 &amp; 3 \\cr 3 &amp; 2 } \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Нехай ми контролюємо другий стан і для нього граничне значення буде дорівнювати 3. Тоді матриця скорочиться наступним чином: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"L' = \\pmatrix{5 &amp; 1 \\cr 6 &amp; 3 \\cr 3 &amp; 2 } \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Розглянемо стан, що не контролюється (перший). Для нього найменше значення – 3. Тобто оптимальний нерандомізований розв’язок – це четверта стратегія. </Paragraph> <Paragraph> <Bold>Алгоритм пошуку рандомізованого розв’язку за критерієм Неймана – Пірсона</Bold> </Paragraph> <List MarkerStyle=\"Decimal\"> <ListItem> <Paragraph> Побудувати платіжну множину D за матрицею втрат </Paragraph> </ListItem> <ListItem> <Paragraph> Виключити із платіжної множини всі точки, для яких значення за станом, що контролюється (значення відповідної координати), більше за граничне. </Paragraph> </ListItem> <ListItem> <Paragraph> Знайти координати точки платіжної множини, якій відповідає найменше значення за станом, що не контролюється. Зазвичай його можна знайти із рівняння: </Paragraph> <BlockUIContainer Margin=\"0, 10\"> <controls:FormulaControl Formula=\"x_i \\pmatrix{l_{i 1} \\cr l_{i 2} } + (1 - x_i) \\pmatrix{l_{j 1} \\cr l_{j 2}} = \\pmatrix{L_{1} \\cr L_{2}} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> де <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"L_{i}\" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer> відповідає граничному значенню стану, що контролюється, і таким чином можна знайти розв’язок. </Paragraph> </ListItem> </List> <Paragraph> <Bold><Italic>Приклад:</Italic></Bold> </Paragraph> <Paragraph> Нехай матриця втрат має вигляд: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"L = \\pmatrix{0 &amp; 4 \\cr 5 &amp; 1 \\cr 6 &amp; 3 \\cr 3 &amp; 2 } \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Нехай ми контролюємо другий стан і для нього граничне значення буде дорівнювати 3. </Paragraph> <Paragraph> Після виключення з платіжної множини точок, значення в яких більше за граничне, одержимо множину, обмежену точками <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"x = \\alpha_4 \" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"x = \\alpha_2 \" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"x = \\alpha_3 \" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>, <InlineUIContainer BaselineAlignment=\"TextBottom\"><controls:FormulaControl Formula=\"x = \\alpha^{*} \" Scale=\"15\" SnapsToDevicePixels=\"True\"/></InlineUIContainer>. Найменшому значенню за станом, що не контролюється, відповідає остання точка. Знайдемо її координати з рівняння: </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"x \\pmatrix{0 \\cr 4} + (1 - x) \\pmatrix{3 \\cr 2} = \\pmatrix{L_{1} \\cr 3} \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Розв'язком цієї системи буде:</Paragraph> <BlockUIContainer><controls:FormulaControl Formula=\"x = \\frac{1}{2} \" Scale=\"20\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\" SnapsToDevicePixels=\"True\"/></BlockUIContainer> <Paragraph> Тобто рандомізований розв’язок за цим критерієм буде </Paragraph> <BlockUIContainer> <controls:FormulaControl Formula=\"(\\frac{1}{2}; 0; 0; \\frac{1}{2}) \" Scale=\"20\" SnapsToDevicePixels=\"True\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/> </BlockUIContainer> <Paragraph> Отже, у одному випадку з двох ми діємо за першим варіантом, а в другому – за четвертим. </Paragraph> </FlowDocument>";
        private static readonly string ThrollStr  = "<?xml version=\"1.0\"?>\r\n<FlowDocument xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\">\r\n<Paragraph TextAlignment=\"Center\" FontFamily=\"{StaticResource WorkSansBlack}\">\r\n                            <Bold>Слухай, а вправно ти це вигадав, я навіть спочатку не зрозумів, молодець...</Bold>\r\n                        </Paragraph>\r\n                        <Paragraph TextAlignment=\"Center\" FontFamily=\"{StaticResource WorkSansBlack}\">\r\n                            <Bold>Але списати тут не вийде(((</Bold>\r\n                        </Paragraph>\r\n                    </FlowDocument>";

        private static readonly string SavageName  = "Критерій Севіджа";
        private static readonly string PearsonName = "Критерій Неймана-Пірсона";

        private static readonly Lazy<DummyTheoryRepository> lazy =
            new (() => new DummyTheoryRepository());

        private DummyTheoryRepository() {

        }

        public static DummyTheoryRepository Instance => DummyTheoryRepository.lazy.Value;

        public FlowDocument GetSavageTheory() {
            return this.IsThroll ?
                System.Windows.Markup.XamlReader.Parse(DummyTheoryRepository.ThrollStr) as FlowDocument : 
                System.Windows.Markup.XamlReader.Parse(DummyTheoryRepository.SavageStr) as FlowDocument;
        }

        public FlowDocument GetPearsonTheory() {
            return this.IsThroll ?
                System.Windows.Markup.XamlReader.Parse(DummyTheoryRepository.ThrollStr) as FlowDocument :
                System.Windows.Markup.XamlReader.Parse(DummyTheoryRepository.PearsonStr) as FlowDocument;
        }

        public string GetSavageName() => DummyTheoryRepository.SavageName;

        public string GetPearsonName() => DummyTheoryRepository.PearsonName;

        public bool IsThroll { get; set; }
    }
}
